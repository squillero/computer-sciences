# Origin: Generated by Microsoft Copilot
# https://github.com/squillero/computer-sciences
# Free under certain conditions â€” see the license for details.

"""
Reads 'report.txt', finds purchased batch numbers that are dangerous,
and prints them (one per line) in the same order as they appear under the
purchased list. Ranges are inclusive and may overlap.

Expected 'report.txt' layout:
- Top section: lines with "start-end"
- A blank line (separator)
- Bottom section: lines with single integers (purchased batch numbers)
"""

from typing import List, Tuple

REPORT_FILE = "report-small.txt"


def parse_report(path: str) -> Tuple[List[Tuple[int, int]], List[int]]:
    """
    Parse the report file. Returns:
      - ranges: list of (start, end) integer tuples
      - purchases: list of purchased batch numbers (ints)
    """
    ranges: List[Tuple[int, int]] = []
    purchases: List[int] = []

    in_bottom_section = False
    with open(path, "r", encoding="utf-8") as f:
        for raw in f:
            line = raw.strip()
            # Detect the blank line that splits the two sections
            if line == "":
                in_bottom_section = True
                continue

            if not in_bottom_section:
                # Parse a range like "a-b"
                # Be tolerant to spaces around the dash
                # e.g., "  10 - 14 "
                cleaned = line.replace(" ", "")
                if "-" not in cleaned:
                    raise ValueError(f"Invalid range line (missing '-'): {line!r}")
                a_str, b_str = cleaned.split("-", 1)
                try:
                    a, b = int(a_str), int(b_str)
                except ValueError:
                    raise ValueError(f"Invalid integers in range line: {line!r}") from None
                if a > b:
                    a, b = b, a  # allow reversed inputs like "14-10"
                ranges.append((a, b))
            else:
                # Parse a purchased batch number
                try:
                    purchases.append(int(line))
                except ValueError:
                    raise ValueError(f"Invalid purchased batch number: {line!r}") from None

    if not ranges:
        # It's valid to have zero ranges (then nothing is dangerous),
        # but likely a mistake. We keep it permissive.
        pass

    return ranges, purchases


def merge_overlapping(ranges: List[Tuple[int, int]]) -> List[Tuple[int, int]]:
    """
    Merge overlapping (inclusive) intervals.
    For example: [(3,5),(4,8)] -> [(3,8)]
    Adjacent non-overlapping intervals (e.g., (3,5) and (6,7)) are NOT merged.
    """
    if not ranges:
        return []

    ranges_sorted = sorted(ranges, key=lambda x: (x[0], x[1]))
    merged: List[Tuple[int, int]] = [ranges_sorted[0]]

    for start, end in ranges_sorted[1:]:
        last_start, last_end = merged[-1]
        if start <= last_end:  # overlap (inclusive)
            merged[-1] = (last_start, max(last_end, end))
        else:
            merged.append((start, end))

    return merged


def is_dangerous(batch: int, merged_ranges: List[Tuple[int, int]]) -> bool:
    """
    Check if 'batch' falls within any merged interval using binary search
    over starts. (A linear scan is also fine if the list is small.)
    """
    # Binary search by interval start
    lo, hi = 0, len(merged_ranges) - 1
    while lo <= hi:
        mid = (lo + hi) // 2
        s, e = merged_ranges[mid]
        if s <= batch <= e:
            return True
        if batch < s:
            hi = mid - 1
        else:  # batch > e
            lo = mid + 1
    return False


def main() -> None:
    ranges, purchases = parse_report(REPORT_FILE)
    merged = merge_overlapping(ranges)

    # Emit purchased batches that are dangerous, preserving input order
    for b in purchases:
        if is_dangerous(b, merged):
            print(b)


if __name__ == "__main__":
    main()
